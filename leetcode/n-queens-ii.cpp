/**
 * @brief https://oj.leetcode.com/problems/n-queens-ii/
 *
 * Follow up for N-Queens problem.
 *
 * Now, instead outputting board configurations, return the total number of distinct solutions.
 * 
 * reference: <<算法竞赛入门经典>> p123
 * 
 * 解：
 * 通过枚举皇后在棋盘中的位置来统计所有可能的情况。
 * 枚举过程利用回溯减少不必要的枚举。
 * 利用皇后间的位置关系还能去除一些不必要的枚举，比如同一行、同一列只能出现一个皇后，所以以后的枚举过程也不必查找同一行同列的坐标。
 * 标识特殊位置关系，可以巧妙的利用数学规律实现。
 *   逐行遍历，保证同一行不会重复遍历
 *   使用hash标记某一列是否已经存在皇后 key是列坐标；value是0（可用，此列无皇后）或1（不可用，此列有皇后）。（其实数组也能实现这样的功能）
 *   使用hash标记左上到右下对角线是否已经存在皇后 
 *   使用hash标记右上到左下对角线是否已经存在皇后 
 *
 * 如下图，y轴表示列（columns）,x轴表示行（rows）
 * 
 *   +-------------> (y)
 *   |
 *   |  +---+---+---+---+---+---+---+---+
 *   |  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
 *   v  +---+---+---+---+---+---+---+---+
 *  (x) | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
 *      +---+---+---+---+---+---+---+---+
 *      | 2 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
 *      +---+---+---+---+---+---+---+---+
 *      | 3 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
 *      +---+---+---+---+---+---+---+---+
 *      | 4 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
 *      +---+---+---+---+---+---+---+---+
 *      | 5 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
 *      +---+---+---+---+---+---+---+---+
 *      | 6 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
 *      +---+---+---+---+---+---+---+---+
 *      | 7 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
 *      +---+---+---+---+---+---+---+---+
 * 
 * 
 * (x,y)的y-x值标识主对角线，左上到右下
 * 
 *   +-------------> (y)
 *   |
 *   |  +---+---+---+---+---+---+---+---+
 *   |  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
 *   v  +---+---+---+---+---+---+---+---+
 *  (x) |-1 | 0 | 1 | 2 | 3 | 4 | 5 | 6 |
 *      +---+---+---+---+---+---+---+---+
 *      |-2 |-1 | 0 | 1 | 2 | 3 | 4 | 5 |
 *      +---+---+---+---+---+---+---+---+
 *      |-3 |-2 |-1 | 0 | 1 | 2 | 3 | 4 |
 *      +---+---+---+---+---+---+---+---+
 *      |-4 |-3 |-2 |-1 | 0 | 1 | 2 | 3 |
 *      +---+---+---+---+---+---+---+---+
 *      |-5 |-4 |-3 |-2 |-1 | 0 | 1 | 2 |
 *      +---+---+---+---+---+---+---+---+
 *      |-6 |-5 |-4 |-3 |-2 |-1 | 0 | 1 |
 *      +---+---+---+---+---+---+---+---+
 *      |-7 |-6 |-5 |-4 |-3 |-2 |-1 | 0 |
 *      +---+---+---+---+---+---+---+---+
 * 
 * 
 * (x,y)的y+x值标识副对角线，右上到左下
 *   +-------------> (y)
 *   |
 *   |  +---+---+---+---+---+---+---+---+
 *   |  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
 *   v  +---+---+---+---+---+---+---+---+
 *  (x) | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
 *      +---+---+---+---+---+---+---+---+
 *      | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
 *      +---+---+---+---+---+---+---+---+
 *      | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10|
 *      +---+---+---+---+---+---+---+---+
 *      | 4 | 5 | 6 | 7 | 8 | 9 | 10| 11|
 *      +---+---+---+---+---+---+---+---+
 *      | 5 | 6 | 7 | 8 | 9 | 10| 11| 12|
 *      +---+---+---+---+---+---+---+---+
 *      | 6 | 7 | 8 | 9 | 10| 11| 12| 13|
 *      +---+---+---+---+---+---+---+---+
 *      | 7 | 8 | 9 | 10| 11| 12| 13| 14|
 *      +---+---+---+---+---+---+---+---+
 * 
 */
#include<stdio.h>
#include<vector>
#include<map>

using namespace std;

map<int,int> queen_pos;   // queen棋子坐标, key:是行坐标; value:是列坐标;
map<int,int> invaild_pos1;// columns,标记某列是否存在皇后， 1:存在, 0:不存在
map<int,int> invaild_pos2;// 标记左上到右下的对角线是否存在皇后
map<int,int> invaild_pos3;// 标记右上到左下的对角线是否存在皇后
int total = 0;
int max_queen = 0;
int search(int cur); 
int totalNQueens(int n);

int main() 
{
	for (int i=0; i<10; i++) {
		int max_queen = i;
		printf("queen=%d, sulotions=%d\n", max_queen, totalNQueens(max_queen));
	}
	return 0;
}


int totalNQueens(int n)
{
	queen_pos.clear();
	invaild_pos1.clear();
	invaild_pos2.clear();
	invaild_pos3.clear();
	total = 0;
	max_queen = n;
	return search(n);
}

int search(int cur) // each rows
{
	cur--;
	if (cur<0) {
		return total++;
	}
	for (int col=0; col<max_queen; col++) { // each columns
		int pos1 = col;
		int pos2 = cur - col + max_queen;
		int pos3 = cur + col;

#if 0
		printf("pos1=%d, pos2=%d, pos3=%d\n"
					,invaild_pos1[pos1]
					,invaild_pos2[pos2]
					,invaild_pos3[pos3]
		);
#endif
		if (!invaild_pos1[pos1] && !invaild_pos2[pos2] && !invaild_pos3[pos3]) {
			queen_pos[cur] = col;

			invaild_pos1[pos1] = invaild_pos2[pos2] = invaild_pos3[pos3] = 1;
			search(cur);
			invaild_pos1[pos1] = invaild_pos2[pos2] = invaild_pos3[pos3] = 0;
		}
	}
	return total;
}


